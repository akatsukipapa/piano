<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Piano 2 Octaves</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; color: white;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; cursor: pointer;
            background: #00d2ff; border: none; border-radius: 50px; color: #000; font-weight: bold;
            margin-top: 20px; transition: 0.3s;
        }
        button:hover { transform: scale(1.1); background: #fff; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>Air Piano (Wide) ğŸ¹</h1>
        <p>ã‚«ãƒ¡ãƒ©ã«å‘ã‹ã£ã¦äººå·®ã—æŒ‡ã§éµç›¤ã‚’ã‚¿ãƒƒãƒã—ã¦ãã ã•ã„</p>
        <button id="start-btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- éŸ³å£°ã‚¨ãƒ³ã‚¸ãƒ³ ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(freq) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.type = 'sine'; 
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 1.0);
        }

        // --- Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // å¤‰æ›´ç‚¹: éµç›¤ãŒå¢—ãˆãŸã®ã§ã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å¾Œã‚(z=11)ã«ä¸‹ã’ã¦å…¨ä½“ã‚’æ˜ ã™
        camera.position.set(0, 5, 11);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- éµç›¤ãƒ‡ãƒ¼ã‚¿ (2ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–åˆ†) ---
        const keys = [];
        const whiteKeyWidth = 1.0;
        const whiteKeyHeight = 0.5;
        const whiteKeyDepth = 3.0;
        
        // C4 (ãƒ‰) ã‹ã‚‰ C6 (é«˜ã„ãƒ‰) ã¾ã§
        const notes = [
            // 1ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ç›®
            { note: 'C4', freq: 261.63, color: 0xffffff },
            { note: 'D4', freq: 293.66, color: 0xffffff },
            { note: 'E4', freq: 329.63, color: 0xffffff },
            { note: 'F4', freq: 349.23, color: 0xffffff },
            { note: 'G4', freq: 392.00, color: 0xffffff },
            { note: 'A4', freq: 440.00, color: 0xffffff },
            { note: 'B4', freq: 493.88, color: 0xffffff },
            // 2ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ç›®
            { note: 'C5', freq: 523.25, color: 0xffffff },
            { note: 'D5', freq: 587.33, color: 0xffffff },
            { note: 'E5', freq: 659.25, color: 0xffffff },
            { note: 'F5', freq: 698.46, color: 0xffffff },
            { note: 'G5', freq: 783.99, color: 0xffffff },
            { note: 'A5', freq: 880.00, color: 0xffffff },
            { note: 'B5', freq: 987.77, color: 0xffffff },
            // æœ€å¾Œã®ãƒ‰
            { note: 'C6', freq: 1046.50, color: 0xffffff }
        ];

        const geometry = new THREE.BoxGeometry(whiteKeyWidth * 0.9, whiteKeyHeight, whiteKeyDepth);
        
        notes.forEach((n, index) => {
            const material = new THREE.MeshStandardMaterial({ color: n.color });
            const key = new THREE.Mesh(geometry, material);
            
            // è‡ªå‹•çš„ã«ä¸­å¤®æƒãˆã§é…ç½®
            key.position.x = (index - notes.length / 2) * whiteKeyWidth + 0.5;
            key.position.y = 0;
            key.position.z = 0;
            
            key.userData = { 
                freq: n.freq, 
                originalColor: n.color,
                isPressed: false,
                cooldown: 0
            };
            scene.add(key);
            keys.push(key);
        });

        // --- ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ« ---
        const particles = [];
        const particleGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });

        function spawnParticles(position) {
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(particleGeo, particleMat.clone());
                mesh.position.copy(position);
                mesh.position.y += 0.3;
                mesh.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.2
                    ),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        // --- ã‚«ãƒ¼ã‚½ãƒ« & ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼ ---
        const cursorGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
        const cursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(cursor);

        const raycaster = new THREE.Raycaster();
        const fingerPos = new THREE.Vector2();
        let isHandDetected = false;

        // --- MediaPipe Hands ---
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                fingerPos.x = - (indexTip.x * 2 - 1); 
                fingerPos.y = - (indexTip.y * 2 - 1);
            } else {
                isHandDetected = false;
                cursor.visible = false;
            }
        });

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);

            if (isHandDetected) {
                raycaster.setFromCamera(fingerPos, camera);
                
                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®æ›´æ–°
                const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.5);
                const targetV = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeY, targetV);
                if (targetV) {
                    cursor.position.copy(targetV);
                    cursor.visible = true;
                }

                const intersects = raycaster.intersectObjects(keys);
                if (intersects.length > 0) {
                    const hitObj = intersects[0].object;
                    if (!hitObj.userData.isPressed && hitObj.userData.cooldown <= 0) {
                        hitObj.userData.isPressed = true;
                        hitObj.userData.cooldown = 15; 
                        playTone(hitObj.userData.freq);
                        hitObj.material.color.set(0x00d2ff);
                        hitObj.position.y = -0.2;
                        spawnParticles(hitObj.position);
                    }
                }
            }

            // éµç›¤ãƒªã‚»ãƒƒãƒˆå‡¦ç†
            keys.forEach(key => {
                if (key.userData.cooldown > 0) key.userData.cooldown--;
                let isIntersecting = false;
                if (isHandDetected) {
                     const intersects = raycaster.intersectObject(key);
                     if (intersects.length > 0) isIntersecting = true;
                }
                if (!isIntersecting && key.userData.isPressed) {
                    key.userData.isPressed = false;
                    key.material.color.set(key.userData.originalColor);
                    key.position.y = 0;
                }
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life -= 0.02;
                p.material.opacity = p.userData.life;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            audioCtx.resume();
            cameraUtils.start();
            animate();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Piano with Hand Tracking</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; color: white;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; cursor: pointer;
            background: #00d2ff; border: none; border-radius: 50px; color: #000; font-weight: bold;
            margin-top: 20px; transition: 0.3s;
        }
        button:hover { transform: scale(1.1); background: #fff; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®éŸ³å£°å†ç”Ÿåˆ¶é™ã‚’è§£é™¤ã™ã‚‹ãŸã‚ï¼‰ -->
    <div id="overlay">
        <h1>Air Piano ğŸ¹</h1>
        <p>ã‚«ãƒ¡ãƒ©ã«å‘ã‹ã£ã¦äººå·®ã—æŒ‡ã§éµç›¤ã‚’ã‚¿ãƒƒãƒã—ã¦ãã ã•ã„</p>
        <button id="start-btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¨ãƒ³ã‚¸ãƒ³ (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(freq) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.type = 'sine'; // éŸ³è‰²: sine, square, sawtooth, triangle
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            // éŸ³ã®æ¸›è¡°ï¼ˆã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼‰
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 1.0);
        }

        // --- Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 6);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ãƒ©ã‚¤ãƒˆ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- ãƒ”ã‚¢ãƒéµç›¤ã®ä½œæˆ ---
        const keys = [];
        const whiteKeyWidth = 1.0;
        const whiteKeyHeight = 0.5;
        const whiteKeyDepth = 3.0;
        
        // ãƒ‰ãƒ¬ãƒŸãƒ•ã‚¡ã‚½ãƒ©ã‚·ãƒ‰ (å‘¨æ³¢æ•°)
        const notes = [
            { note: 'C', freq: 261.63, color: 0xffffff },
            { note: 'D', freq: 293.66, color: 0xffffff },
            { note: 'E', freq: 329.63, color: 0xffffff },
            { note: 'F', freq: 349.23, color: 0xffffff },
            { note: 'G', freq: 392.00, color: 0xffffff },
            { note: 'A', freq: 440.00, color: 0xffffff },
            { note: 'B', freq: 493.88, color: 0xffffff },
            { note: 'C2', freq: 523.25, color: 0xffffff }
        ];

        const geometry = new THREE.BoxGeometry(whiteKeyWidth * 0.9, whiteKeyHeight, whiteKeyDepth);
        
        // éµç›¤ã‚’ä¸¦ã¹ã‚‹
        notes.forEach((n, index) => {
            const material = new THREE.MeshStandardMaterial({ color: n.color });
            const key = new THREE.Mesh(geometry, material);
            
            // é…ç½® (ä¸­å¤®æƒãˆ)
            key.position.x = (index - notes.length / 2) * whiteKeyWidth + 0.5;
            key.position.y = 0;
            key.position.z = 0;
            
            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¿½åŠ 
            key.userData = { 
                freq: n.freq, 
                originalColor: n.color,
                isPressed: false,
                cooldown: 0
            };
            
            scene.add(key);
            keys.push(key);
        });

        // --- ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ  (æ‰“éµæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ) ---
        const particles = [];
        const particleGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });

        function spawnParticles(position) {
            for(let i=0; i<10; i++) {
                const mesh = new THREE.Mesh(particleGeo, particleMat.clone());
                mesh.position.copy(position);
                mesh.position.y += 0.3; // å°‘ã—ä¸Šã‹ã‚‰
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦
                mesh.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.2
                    ),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        // --- æŒ‡å…ˆã‚«ãƒ¼ã‚½ãƒ« (è¦–è¦šã‚¬ã‚¤ãƒ‰) ---
        const cursorGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
        const cursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(cursor);

        // --- å½“ãŸã‚Šåˆ¤å®šç”¨ ---
        const raycaster = new THREE.Raycaster();
        const fingerPos = new THREE.Vector2(); // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ (-1 ~ 1)
        let isHandDetected = false;

        // --- MediaPipe Hands è¨­å®š ---
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Liteãƒ¢ãƒ‡ãƒ«
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // äººå·®ã—æŒ‡ã®å…ˆç«¯ (Index Finger Tip: #8)
                const indexTip = landmarks[8];

                // MediaPipeã®åº§æ¨™(0~1)ã‚’Three.jsã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™(-1~1)ã«å¤‰æ›
                // â€» ãƒŸãƒ©ãƒ¼ãƒªãƒ³ã‚°ã—ã¦ã„ã‚‹ãŸã‚ã€Xè»¸ã‚’åè»¢ã•ã›ã‚‹
                fingerPos.x = - (indexTip.x * 2 - 1); 
                fingerPos.y = - (indexTip.y * 2 - 1);
                
            } else {
                isHandDetected = false;
                cursor.visible = false;
            }
        }

        // --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. ã‚«ãƒ¼ã‚½ãƒ«ã¨å½“ãŸã‚Šåˆ¤å®šã®æ›´æ–°
            if (isHandDetected) {
                // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆã‚«ãƒ¡ãƒ©ã‹ã‚‰æŒ‡ã®æ–¹å‘ã¸ç·šã‚’é£›ã°ã™ï¼‰
                raycaster.setFromCamera(fingerPos, camera);
                
                // ã‚«ãƒ¼ã‚½ãƒ«ã‚’ãƒ¬ã‚¤ä¸Šã®ä¸€å®šè·é›¢ã«è¡¨ç¤ºï¼ˆç–‘ä¼¼çš„ãª3Dä½ç½®ï¼‰
                const rayDir = raycaster.ray.direction.clone().multiplyScalar(10); // è·é›¢é©å½“
                // cursor.position.copy(camera.position).add(rayDir); 
                // ã‚‚ã£ã¨å˜ç´”ã«ã€ãƒ¬ã‚¤ã¨å¹³é¢(y=0.2ãã‚‰ã„)ã®äº¤ç‚¹ã‚’è¨ˆç®—ã—ã¦ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç½®ã
                const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.5); // y=0.5ã®å¹³é¢
                const targetV = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeY, targetV);
                if (targetV) {
                    cursor.position.copy(targetV);
                    cursor.visible = true;
                }

                // éµç›¤ã¨ã®äº¤å·®åˆ¤å®š
                const intersects = raycaster.intersectObjects(keys);

                if (intersects.length > 0) {
                    const hitObj = intersects[0].object;
                    
                    // ã¾ã æŠ¼ã•ã‚Œã¦ã„ãªã„ã€ã‹ã¤ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ¸ˆã¿ãªã‚‰ç™ºéŸ³
                    if (!hitObj.userData.isPressed && hitObj.userData.cooldown <= 0) {
                        hitObj.userData.isPressed = true;
                        hitObj.userData.cooldown = 15; // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã§å†ãƒˆãƒªã‚¬ãƒ¼åˆ¶é™
                        
                        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                        playTone(hitObj.userData.freq);
                        hitObj.material.color.set(0x00d2ff); // é’ãå…‰ã‚‹
                        hitObj.position.y = -0.2; // å°‘ã—æ²ˆã‚€
                        spawnParticles(hitObj.position);
                    }
                }
            }

            // 2. éµç›¤ã®çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
            keys.forEach(key => {
                if (key.userData.cooldown > 0) key.userData.cooldown--;

                // æŒ‡ãŒé›¢ã‚Œã¦ã„ãŸã‚‰å…ƒã«æˆ»ã™
                let isIntersecting = false;
                if (isHandDetected) {
                     const intersects = raycaster.intersectObject(key);
                     if (intersects.length > 0) isIntersecting = true;
                }

                if (!isIntersecting && key.userData.isPressed) {
                    key.userData.isPressed = false;
                    key.material.color.set(key.userData.originalColor);
                    key.position.y = 0; // å…ƒã®é«˜ã•ã¸
                }
            });

            // 3. ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life -= 0.02;
                p.material.opacity = p.userData.life;
                
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- åˆæœŸåŒ–å‡¦ç† ---
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            audioCtx.resume();
            cameraUtils.start();
            animate();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
